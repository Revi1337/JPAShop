// 현재 api package 의 모든 컨트롤러에서 Service 가 아닌 Repository 를 직접 참조하여 단순한 엔티티를 조회하는데 @Transactional 이 필요없는 이유.
- Repository 를 통해 직접 DB 에 접근할 때의 방법은 두가지가 있음.
1. 리포지토리 조회 기능에 명시적으로 읽기 트랜잭션을 적용한다.(@Tranactional(readOnly = true))
	- 1번의 경우 리포지토리에서 데이터베이스 커넥션을 획득하고, DB와 트랜잭션을 시작함. 이것을 읽기 전용 트랜잭션 사용이라 함.(스프링 Data JPA 는 이 방식을 사용함)
2. 리포지토리 조회 기능에 트랜잭션을 명시하지 않는다.
	- 2번의 경우는 트랜잭션을 시작하지 않고, 단순히 커넥션을 획득해서 데이터베이스에 바로 쿼리로 조회를 요청합니다. 이것을 트랜잭션 밖에서 읽기라 함. JPA에서 데이터를 변경할 때는 트랜잭션이 필수지만 읽기만 할 때는 트랜잭션이 없어도 동작함.
    * 하지만 OSIV (Open Session In View)가 false 로 되어있으면 Controller 단에서는 DB 커넥션이 없고,
      Persistence Context 가 없기 때문에, Controller 단에서 지연로딩으로 인한 Proxy 객체를 초기화할떄 No Session Exception 이 발생함.

--> 결론 : JPA 에서 데이터를 변경하는데는 꼭 Transaction 안에서 EntityManger 를 통해 영속성컨텍스트에 접근해 데이터를 변경해야하지만
          단순히 값을 조회할떄는 Transaction 이 필요가 없다.
          결국, "단순히 값을 조회할때" 는 Transaction 이 필요가없고, @Transactional 을 붙이지 않아도 된다.
          조심해야할 것은 OSIV (Open Session In View)가 false 로되어있으면 프록시객체를 초기화할떄 No Session 이 뜬다.
